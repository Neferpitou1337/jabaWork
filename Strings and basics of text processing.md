### 																				Strings

1. Как создать объект класса **String**, какие конструкторы класса **String** вы знаете? Что такое строковый литерал? Объясните, что значит “упрощенное создание объекта **String**”?

   - С помощью конструктора как любой объект или упрощенного создания.

   - ```java
     // Default constructor:
     // String with no characters in it
     String s = new String();
     
     /*To have initial values in it:*/
     // Initialize by array of chars
     char[]chars = {'H','e','l','l','o'};
     String s1 = new String(chars);
     
     // Specify start index and number of characters
     String s2 = new String(chars,1,3);
     
     // Copying constructor
     String s3 = new String(s2);
     
     // Due 8bit ASCII strings are common two form of constructors:
     byte[] ascii = {65,66,67,68,69};
     String s4 = new String(ascii);
     String s5 = new String(ascii,2,3);
     
     // Using StringBuffer and StringBuilder
     String s6 = new String(new StringBuffer("aaaa"));
     String s7 = new String(new StringBuilder("bbbb"));
     
     // Using extended Unicode characters set:
     int [] codePoints = {1234,4211,4321,4643,7345};
     String sU1 = new String(codePoints,0,codePoints.length);
     ```

   - Строковые литералы — это набор символов, заключенных в двойные кавычки. В строке  также могут находится служебные символы, которые необходимо экранировать (так называемые escape-последовательности). 

   - ```java
     String slast = "Hello, world";
     ```

2. Можно ли изменить состояние объекта типа **String**? Что происходит при попытке изменения состояния объекта типа String? Можно ли наследоваться от класса **String**? Как вы думаете, почему строковые объекты immutable?

   - Нет, создавая объект **String**, мы создаем неизменяемый объект.
   - Он просто возвращает изменения с помощью return, а сам не изменяется. Но ссылку на объект **String** мы можем поменять
   - Нет нельзя, как и от  **StringBuilder** и **StringBuffer**, это сделано, чтобы можно было применить некоторые оптимизации в обычных операциях со строками
   - Есть несколько преимуществ в неизменности строк:
     1. Строковый пул возможен только потому, что строка неизменна в  Java, таким образом виртуальная машина сохраняет много места в памяти  (heap space), поскольку разные строковые переменные указывают на одну  переменную в пуле. Если бы строка не была неизмененяемой, тогда бы  интернирование строк не было бы возможным, потому что если какая-либо  переменная изменит значение, это отразится также и на остальных  переменных, ссылающихся на эту строку.
     2. Если строка будет изменяемой, тогда это станет серьезной  угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в  программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в  противном случае любой хакер может изменить значение ссылки и вызвать  проблемы в безопасности приложения.
     3. Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными  тредами. Это позволяет избежать синхронизации для потокобезопасности,  строки полностью потокобезопасны.
     4. Поскольку строка неизменная, её `hashcode` кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в `Map` и его обработка будет быстрее, чем других ключей `HashMap`. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа `HashMap`.

3. Объясните, что такое кодировка? Какие кодировки вы знаете? Как создать строки в различной кодировке?

   - кодировкой называется набор символов и соответствующий им набор кодов

   - **ASCII**, **Unicode**, **UTF-8**, **Windows-1251**

   - ```java
     String s = "Good news everyone!";
     Charset utf8 = StandardCharsets.UTF_8;
     // Переводим строку в массив байтов в кодировке UTF-8
     byte[] buffer = s.getBytes(utf8);
     // Специальный конструктор для массива байтов и кодировки
     s = new String(buffer, utf8);
     System.out.println(s);
     ```

     Остается только переводить строки из стандартной кодировки в самые разные с помощью конструктора **String**

4. Что такое пул литералов? Как строки заносятся в пул литералов? Как занести строку в пул литералов и как получить ссылку на строку, хранящуюся в пуле литералов? Где хранится(в каком типе памяти) пул литералов в Java 1.6 и Java 1.7?

   Как видим из ниже написанного с другими литералами во **Wrapper** классах случается такая же хуйня что и со **String** потому то они все и константные объекты, лол

   - ```java
     Integer in = 5;
     Integer in2 = 5;
     
     System.out.println(in == in2);//true
     in2 = 5;
     System.out.println(in == in2);//true
     in2 = 6;
     System.out.println(in == in2);//false
     ```

   - Здесь же если создается через new, то он не попадает в пул **Integer**

     ```java
     Integer in = 5;
     Integer in2 = new Integer(5);
     
     System.out.println(in == in2);//false
     in2 = 6;
     System.out.println(in == in2);//false
     ```

   - Как подсказывает название, пул строк – это набор строк, который хранится в памяти Java heap. Мы знаем, что `String` это специальный класс в Java, и мы можем создавать объекты этого  класса, используя оператор new точно так же, как и создавать объекты,  предоставляя значение строки в двойных кавычках. 

     <img src="C:\Users\isahe\IdeaProjects\img\String-Pool-Java1-450x249.png" alt="String-Pool-Java1-450x249" style="zoom:125%" />

   - Пул строк возможен исключительно благодаря неизменяемости строк в Java и  реализации идеи интернирования строк. Пул строк также является примером  паттерна Приспособленец (Flyweight). Пул строк помогает экономить большой объем памяти, но с другой стороны  создание строки занимает больше времени. Когда мы используем двойные кавычки для создания строки, сначала ищется  строка в пуле с таким же значением, если находится, то просто  возвращается ссылка, иначе создается новая строка в пуле, а затем  возвращается ссылка. Тем не менее, когда мы используем оператор new, мы  принуждаем класс `String` создать новый объект строки, а затем мы можем использовать метод `intern()` для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект **String** с таким же значением. Ниже приведен пример, показывающий работу пула строк.

     ```java
     String s = "Good news everyone!";
     String a = s.intern();
     System.out.println(s==a);// true
     ```

   - Когда метод **intern()** вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом **equals(Object)**, тогда возвращается ссылка на строку из пула. В противном случае объект  строки добавляется в пул и ссылка на этот объект возвращается.
   - В куче хранится, а ссылка на объект в стэке, даже в книги EPAMa такой хуйни нет, как различие версий

5. В чем отличие объектов классов **StringBuilder** и **StringBuffer** от объектов класса **String**? Какой из этих классов потокобезопасный? Как необходимо сравнивать на равенство объекты классов **StringBuilder** и **StringBuffer** и почему?

   - Они изменяемы. Так как **String** содержит неизменяемую строку фиксированной длины, в **StringBuilder** и **StringBuffer**, наоборот, изменяемые как по длине так и по сути, они будут расти автоматически с требуемой задачей.
   -  **StringBuffer**, зато **StringBuilder** быстрее.
     - Их необходимо приводить к **String** и вызывать метод **equals()** или **equalsIgnoreCase()**

6. Что такое Unicode?

   **Unicode** — это международный стандарт кодировки  символов, который может представлять большинство письменных языков по  всему миру. Юникод использует шестнадцатеричное для представления  символа. Unicode — это 16-битная система кодирования символов.  Наименьшее значение равно \u0000, а самое высокое значение равно \uFFFF.

7.  Какие методы класса **String** используются для работы с кодовыми точками? Как вы думаете, когда следует их использовать?

   - ```java
     // Using extended Unicode characters set:
     int [] codePoints = {1234,4211,4321,4643,7345};
     String sU1 = new String(codePoints,0,codePoints.length);
     ```

   - **codePointAt(int i)**, 
   - **codePointBefore(int i)**,
   - **codePointCount(int start,int end)**,
   - **offsetByPointCount(int start,int num)**
   - Когда символы выходят за границы **Unicode** 
   
### Regular Expressions 

1. Расскажите, что представляет собой регулярное выражение? Что такое метасимволы регулярного выражения? Какие вы знаете классы символов регулярных выражений? Что такое квантификаторы? Какие логические операторы регулярных выражений вы знаете? Что значит “якорь” для регулярного выражения? 
   
   - Регулярное выражение — это описание шаблона символов.
   
     `.` — соответствует любому символу;
   
     `[ ]` — совпадает с символом из диапазона, содержащегося в квадратных скобках;
   
     `[^]` — соответствует символам, которые не входят в диапазон, содержащийся в квадратных скобках;
   
    
   
     `\` — экранирование или отмена специального значения указанного символа.
   
    **диапазоны(якоря)**
   
   ​	`$` - конец строки
   
   ​	 `^` - начало строки
   
   **Метасимволы** - это символы, которые имеют особое значение. 
   
   ` \`- экранирование
   
   `\d` - любую цифру
   
   `\D` - все что угодно, кроме цифр
   
   `\s` - пробелы
   
   `\S` - все кроме пробелов
   
   `\w` - буква
   
   `\W` - все кроме букв
   
   `\b` — представляет либо начало, либо конец слова.
   
     `\<` — представляет начало слова.
   
     `\>` — представляет конец слова.
   
   `\B` - не граница
   
   **Квантификация**:
   
      `*` — совпадение 0 или более раз с указанным элементом;
   
     `+` — совпадение 1 или более раз с указанным элементом;
   
     `?` — совпадение 0 или 1 раз с указанным элементом;
   
     `{n}` — точное совпадение n раз указанного элемента;
   
     `{n, m}` — точное совпадение от n до m раз указанного элемента;
   
     `{n, }` — точное совпадение n или более раз указанного элемента;
   
   
   
   При опережающей проверке мы хотим заглянуть вперёд (отсюда и имя) нашей  строки и посмотреть, соответствует ли она заданному шаблону или нет.  Если соответствие найдено, то мы его игнорируем и продолжаем поиск
   
     `()` — группируем часть регулярного выражения;
   
     `\1`, `\2` и т.д. — ссылаемся на соответствие, найденное группой ранее;
   
     `|` — оператор ИЛИ: ищем соответствие либо правому, либо левому операнду;
   
     `(?=x)` — позитивная опережающая проверка;
   
   ![image-20201104225601660](C:\Users\isahe\AppData\Roaming\Typora\typora-user-images\image-20201104225601660.png)
   
     `(?!x)` — негативная опережающая проверка;
   
   ![regex](C:\Users\isahe\IdeaProjects\img\regex.png)
   
     `(?<=x)` — позитивная ретроспективная проверка;
   
   ​                                                                                                	![re](C:\Users\isahe\IdeaProjects\img\re.png)
   
     `(?<!x)` — негативная ретроспективная проверка.
   
   `(?(?=condition)(then1|then2|then3)|(else1|else2|else3))`
   
2. Какие java-классы работают с регулярными выражениями? В каком пакете они расположены? Приведите пример анализа текста с помощью регулярного выражения и поясните код примера.

   - Pattern, Matcher

     ```java
        String s = "isachenko.foxrider@yandex.by isahenko.daria@gmail.com as005409@g.bstu.by";
        Pattern p = null;
        Matcher m;
        p = Pattern.compile("[A-Za-z0-9\\.-]+@[A-za-z\\.]+");
        m = p.matcher(s);
        
        System.out.println(m.replaceAll("hui"));
     ```

   - util.regex

   - Код выше проверяет строку на соответствие с почтой, Описан максимально базово, так как проще просто уже отправить сообщение на почту, а если не дошло попросить проверить свой ввод.

     

   

3. Что такое группы в регулярных выражениях? Как нумеруются группы? Что представляет собой группа номер 0(ноль)? Приведите пример с использованием групп регулярного выражения.

   - Группа - это пронумерованная часть регулярного выражения.
      
   - Группа 1 - к подвыражению, начинающемуся с открывающей круглой скобки "(" и заканчивающемуся закрывающей круглой скобкой ")"
      
   - Группа 0 всегда относится ко всему выражению

   - *Регулярное выражение*: 

     **(\b[A-Z]\w+\b) Smith.\*\1 Smith** 

     *Пример*: Harold Smith went to meet **John Smith but John Smith** was not there.

